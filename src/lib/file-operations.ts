// File operations for local save/open with File System Access API

export interface ArduIDEFile {
  name: string;
  blocklyXml: string;
  generatedCode: string;
  board: string;
  version: string;
  exportedAt: string;
}

const FILE_EXTENSION = '.arduide';
const FILE_TYPE = {
  description: 'ArduIDE Project',
  accept: {
    'application/json': [FILE_EXTENSION],
  },
};

// Check if File System Access API is supported
export const isFileSystemAccessSupported = (): boolean => {
  return 'showSaveFilePicker' in window && 'showOpenFilePicker' in window;
};

// Export project to PC using File System Access API or fallback
export const exportToFile = async (
  name: string,
  blocklyXml: string,
  generatedCode: string,
  board: string
): Promise<boolean> => {
  const fileData: ArduIDEFile = {
    name,
    blocklyXml,
    generatedCode,
    board,
    version: '1.0',
    exportedAt: new Date().toISOString(),
  };

  const jsonContent = JSON.stringify(fileData, null, 2);
  const fileName = `${name.replace(/[^a-zA-Z0-9-_]/g, '_')}${FILE_EXTENSION}`;

  if (isFileSystemAccessSupported()) {
    try {
      const handle = await (window as any).showSaveFilePicker({
        suggestedName: fileName,
        types: [FILE_TYPE],
      });
      const writable = await handle.createWritable();
      await writable.write(jsonContent);
      await writable.close();
      return true;
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return false; // User cancelled
      }
      console.error('File save error:', error);
      // Fallback to download
      return downloadFile(jsonContent, fileName);
    }
  } else {
    // Fallback for browsers without File System Access API
    return downloadFile(jsonContent, fileName);
  }
};

// Fallback download method
const downloadFile = (content: string, fileName: string): boolean => {
  const blob = new Blob([content], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  return true;
};

// Import project from PC using File System Access API or fallback
export const importFromFile = async (): Promise<ArduIDEFile | null> => {
  if (isFileSystemAccessSupported()) {
    try {
      const [handle] = await (window as any).showOpenFilePicker({
        types: [FILE_TYPE],
        multiple: false,
      });
      const file = await handle.getFile();
      const content = await file.text();
      return parseArduIDEFile(content);
    } catch (error: any) {
      if (error.name === 'AbortError') {
        return null; // User cancelled
      }
      console.error('File open error:', error);
      // Fallback to input element
      return importFromFileInput();
    }
  } else {
    // Fallback for browsers without File System Access API
    return importFromFileInput();
  }
};

// Fallback import using hidden file input
const importFromFileInput = (): Promise<ArduIDEFile | null> => {
  return new Promise((resolve) => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = FILE_EXTENSION + ',.json';
    
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (!file) {
        resolve(null);
        return;
      }
      
      try {
        const content = await file.text();
        resolve(parseArduIDEFile(content));
      } catch (error) {
        console.error('Error reading file:', error);
        resolve(null);
      }
    };
    
    input.oncancel = () => resolve(null);
    input.click();
  });
};

// Parse and validate ArduIDE file content
const parseArduIDEFile = (content: string): ArduIDEFile | null => {
  try {
    const data = JSON.parse(content);
    
    // Validate required fields
    if (!data.name || !data.blocklyXml) {
      throw new Error('Invalid ArduIDE file: missing required fields');
    }
    
    return {
      name: data.name,
      blocklyXml: data.blocklyXml,
      generatedCode: data.generatedCode || '',
      board: data.board || 'arduino:avr:uno',
      version: data.version || '1.0',
      exportedAt: data.exportedAt || new Date().toISOString(),
    };
  } catch (error) {
    console.error('Error parsing ArduIDE file:', error);
    return null;
  }
};

// Export just the Arduino code as .ino file
export const exportAsIno = async (
  code: string,
  projectName: string
): Promise<boolean> => {
  const header = `// Generated by ArduIDE
// Project: ${projectName}
// Date: ${new Date().toISOString()}

`;
  const content = header + code;
  const fileName = `${projectName.replace(/[^a-zA-Z0-9-_]/g, '_')}.ino`;

  if (isFileSystemAccessSupported()) {
    try {
      const handle = await (window as any).showSaveFilePicker({
        suggestedName: fileName,
        types: [{
          description: 'Arduino Sketch',
          accept: { 'text/plain': ['.ino'] },
        }],
      });
      const writable = await handle.createWritable();
      await writable.write(content);
      await writable.close();
      return true;
    } catch (error: any) {
      if (error.name === 'AbortError') return false;
      return downloadFile(content, fileName);
    }
  } else {
    return downloadFile(content, fileName);
  }
};
